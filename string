// Reverse string

class Solution {
public:
    void reverseString(vector<char>& s) {
        int i=0,j=s.size()-1;
        while(i<j){
            swap(s[i++],s[j--]);
        }
    }    
};

// Palindrome String

class Solution{
public:
	int isPalindrome(string S)
	{
        int start=0;
        int end=S.length()-1;
        while(start<=end){
             if(S[start++]!=S[end--]){
                return 0;
             }
        }
        return 1;
	}
};

// Print all the duplicates in the input string

// C++ program to count all duplicates
// from string using maps
#include <bits/stdc++.h>
using namespace std;
void printDups(string str)
{
	map<char, int> count;
	for (int i = 0; i < str.length(); i++) {
		count[str[i]]++;
	}

	for (auto it : count) {
		if (it.second > 1)
			cout << it.first << ", count = " << it.second
				<< "\n";
	}
}
/* Driver code*/
int main()
{
	string str = "test string";
	printDups(str);
	return 0;
}

// Why Java Strings are Immutable?

https://www.geeksforgeeks.org/java-string-is-immutable-what-exactly-is-the-meaning/

// Check if given strings are rotations of each other or not

#include <bits/stdc++.h>
using namespace std;
/* Function checks if passed strings (str1 and str2) are rotations of each other */
bool areRotations(string str1, string str2)
{
	/* Check if sizes of two strings are same */
	if (str1.length() != str2.length())
		return false;

	string temp = str1 + str1;
	return (temp.find(str2) != string::npos);
}
/* Driver code */
int main()
{
	string str1 = "AACD", str2 = "ACDA";

	// Function call
	if (areRotations(str1, str2))
		printf("Strings are rotations of each other");
	else
		printf("Strings are not rotations of each other");
	return 0;
}

// Check if a string is a valid shuffle of two distinct strings

#include<iostream>
#include<string>
using namespace std;
int main(){
    string s1,s2;
    cin>>s1>>s2;
    string res;
    cin>>res;
    int l1=s1.length();
    int l2=s2.length();
    int lr=res.length();
    if((l1+l2)!=lr){
        cout<<"No";
    }
    else{
        int f=0,i=0,j=0,k=0;
        while(k<lr){
            if(i<l1 && s1[i]==res[k]){
                i++;
            }
            else if(j<l2 && s2[j]==res[k]){
                j++;
            }
            else{
                f=1;
                break;
            }
            k++;
        }
        if(i<l1 || j<l2){
            cout<<"No";
        }
        else{
            cout<<"Yes";
        }
    }
}

// Count and Say

class Solution {
public:
    string countAndSay(int n) {
        if(n==1){
            return "1";
        }
        if(n==2){
            return "11";
        }
        string s="11";
        for(int i=3;i<=n;i++){
            string t="";
            s=s+'&';
            int c=1;
            for(int j=1;j<s.length();j++){
                if(s[j]!=s[j-1]){
                    t=t+to_string(c);
                    t=t+s[j-1];
                    c=1;
                }
                else{
                    c++;
                }
            }
            s=t;
        }
        return s;
    }
};

// Longest plaindrome in a string

string longestPalin (string S) {
        // code here
        int start = 0;
        int end = 1;

        for(int i=1;i<S.size();i++)
        {
            int low = i-1;
            int high = i;
            while(low>=0 && high<S.size()&& S[low]==S[high])
            {
                if(high-low+1>end)
                {
                    start = low;
                    end = high-low+1;
                }

                low--;
                high++;
            }

            low = i-1;
            high = i+1;
            while(low>=0 && high<S.size()&& S[low]==S[high])
            {
                if(high-low+1>end)
                {
                    start = low;
                    end = high-low+1;
                }

                low--;
                high++;
            }

        }

        string ans = "";
        for(int i=start;i<=start+end-1;i++)
        {
            ans = ans+S[i];
        }
   return ans;
}

// Longest Repeating subsequence

class Solution {
    public:
    int LongestRepeatingSubsequence(string str){
        int n = str.size();
        vector <vector <int>> dp(n + 1,vector <int> (n + 1,0));
        for(int i = 1;i <= n;i++){
            for(int j = 1;j <=n;j++){
                if(str[i - 1] == str[j - 1] and i != j){
                    dp[i][j] = 1 + dp[i-1][j-1];
                }
                else{
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[n][n];
    }
};

// Print all subsequences of a string

#include<iostream>
using namespace std;
void func(string str,int start,int n,string s){
    if(start==n){
        cout<<str<<endl;
    }
    else{
        func(str,start+1,n,s);
        str=str+s[start];
        func(str,start+1,n,s);
    }
}
int main(){
    string s;
    cin>>s;
    func("",0,s.length(),s);
    return 0;
}

// Permutations of a given string

(Method-1 => Using next_permutation stl)
class Solution{
	public:
		vector<string>find_permutation(string s)
		{
		    sort(s.begin(),s.end());
            vector<string>ans;
            do{
                ans.push_back(s);
            }
            while(next_permutation(s.begin(),s.end()));
            return ans;
        }
};

(Method-2)
class Solution{
    public:
    void solve(string s,int n,set<string>&st){
        if(n==0){
            st.insert(s);
            return;
        }
        
        for(int i=n;i>=0;i--){
            string temp=s;
            swap(temp[i],temp[n]);
            solve(temp,n-1,st);
        }
    }
    vector<string> find_permutation(string s){
        int n=s.size();
        set<string>st;
            
        solve(s,n-1,st);
        vector<string>ans;
        for(auto i:st){
            ans.push_back(i);
        }
        sort(ans.begin(),ans.end());
        return ans;
    }
};


// Split the binary string into substrings with equal number of 0s and 1s

class Solution {
public:
    int maxSubStr(string str){
        int n= str.length();
        int count=0;
        int ans=0;
        for(int i=0;i<n;i++){
            if(str[i]=='0'){
                count++;    
            } 
            if(str[i]=='1'){
                count--;
            } 
            if(count==0){
                ans++;
            }  
        }
        if(count!=0){
            return -1;    
        } 
        return ans;
    }
};

// Word Wrap

class Solution{
    public:
      int solveWordWrap(vector<int>nums, int k){ 
            int n=nums.size();
            vector<int> dp(n,1000000000);
            int ans[n];
            int cost=0;
            int curlen=0;
            dp[n-1]=0;
            ans[n-1]=n-1;
            for(int i=n-2;i>=0;i--)
            {
                curlen=-1;
                for(int j=i;j<n;j++)
                {
                    curlen+=nums[j]+1;
                    if(curlen>k)
                    break;
                    if(j==n-1)
                    cost=0;
                    else
                    {
                        cost=pow(k-curlen,2)+dp[j+1];
                    }
                    if(cost<dp[i])
                    {
                        dp[i]=cost;
                        ans[i]=j;
                    }
                }
            }
            return dp[0];
        } 
};

// Edit Distance

class Solution{
    public:
    int editDistance(string s, string t)
    {
        int m = s.length();
        int n = t.length();
        vector<vector<int>> dp(m+1, vector<int>(n+1));
        for (int i = 0; i <= m; i++)
        {
            for (int j = 0; j <= n; j++)
            {
                if (i == 0)
                {
                    dp[i][j] = j;
                }
                else if (j == 0)
                {
                    dp[i][j] = i;
                }
                else if (s[i-1] == t[j-1]) 
                {
                    dp[i][j] = dp[i-1][j-1];
                }
                else
                {
                    dp[i][j] = 1 + min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]));
                }
            }
        }
        return dp[m][n];
    }
};

// Next Permutation

class Solution{
public:
    vector<int> nextPermutation(int N, vector<int> arr){
        int i;
        int index=-1;
        for(int i=N-2;i>=0;i--){ // piche se dekho increasing order pe hai array.
           if(arr[i]<arr[i+1]){  // pehle wo index dhundho jahape ye order break ho raha (BREAKPOINT).
               index=i;          // agar nehi mila index to index= -1 hi rahega.
               break;
           }
        }
        // EDGE CASE 
        if(index==-1){   
            reverse(arr.begin(),arr.end()); // nahi mila matlab yeh last permutation hai 
            return arr;                     // so reverse karke return kar do pehla permutation
        }  
        
        for(int i=N-1;i>index;i--){ // ab piche se check karo konsa wala element just
            if(arr[i]>arr[index]){  // greater hai breakpoint wala element se. array
                swap(arr[i],arr[index]); // piche se increasing order main hai. so
                break;  // loop chalake easily find out kar liya konsa just greater hai.
            }  // ab dono element ko swap kardo.
        }
        reverse(arr.begin()+(index+1),arr.end()); // ab jaha pe array ka breakpoint
        return arr;// mila useke baadke index se baki ka array sort ya reverse kar do.
    }
};

// Parenthesis Checker

class Solution
{
    public:
    bool ispar(string x)
    {
        stack<char> st;
        for(int i=0; i < x.length(); i++){
            char a = x[i];
            if(a == '[' || a == '(' || a == '{'){
                st.push(a);
            }
            else{
                if(st.empty()){
                    return false;
                }
                else{
                    char t = st.top(); // for the top element of the stack
                    if(t == '(' && a == ')' || t == '[' && a == ']' || t == '{' && a == '}'){
                        st.pop();
                    }
                    else{
                        return false;
                    }
                }
            }
        }
        return st.empty();
    }
};

// Word Break

class Solution{
public:
// A : given string to search
// B : vector of available strings
    int func(int id,string &A,vector<string> &B){
        string ans = "";
        if(id >= A.size()){
            return 1;
        }
        for(int i = id;i<A.size();i++){
            ans += A[i];
            if(find(B.begin(),B.end(),ans) != B.end()){
                if(1 and func(i+1,A,B)){
                    return true;
                }
            }
        }
        return 0;
    }
    int wordBreak(string A, vector<string> &B) {
       return func(0,A,B);
    }
};
