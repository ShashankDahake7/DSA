// Reverse string

class Solution {
public:
    void reverseString(vector<char>& s) {
        int i=0,j=s.size()-1;
        while(i<j){
            swap(s[i++],s[j--]);
        }
    }    
};

// Palindrome String

class Solution{
public:
	int isPalindrome(string S)
	{
        int start=0;
        int end=S.length()-1;
        while(start<=end){
             if(S[start++]!=S[end--]){
                return 0;
             }
        }
        return 1;
	}
};

// Print all the duplicates in the input string

// C++ program to count all duplicates
// from string using maps
#include <bits/stdc++.h>
using namespace std;
void printDups(string str)
{
	map<char, int> count;
	for (int i = 0; i < str.length(); i++) {
		count[str[i]]++;
	}

	for (auto it : count) {
		if (it.second > 1)
			cout << it.first << ", count = " << it.second
				<< "\n";
	}
}
/* Driver code*/
int main()
{
	string str = "test string";
	printDups(str);
	return 0;
}

// Why Java Strings are Immutable?

https://www.geeksforgeeks.org/java-string-is-immutable-what-exactly-is-the-meaning/

// Check if given strings are rotations of each other or not

#include <bits/stdc++.h>
using namespace std;
/* Function checks if passed strings (str1 and str2) are rotations of each other */
bool areRotations(string str1, string str2)
{
	/* Check if sizes of two strings are same */
	if (str1.length() != str2.length())
		return false;

	string temp = str1 + str1;
	return (temp.find(str2) != string::npos);
}
/* Driver code */
int main()
{
	string str1 = "AACD", str2 = "ACDA";

	// Function call
	if (areRotations(str1, str2))
		printf("Strings are rotations of each other");
	else
		printf("Strings are not rotations of each other");
	return 0;
}

// Check if a string is a valid shuffle of two distinct strings

#include<iostream>
#include<string>
using namespace std;
int main(){
    string s1,s2;
    cin>>s1>>s2;
    string res;
    cin>>res;
    int l1=s1.length();
    int l2=s2.length();
    int lr=res.length();
    if((l1+l2)!=lr){
        cout<<"No";
    }
    else{
        int f=0,i=0,j=0,k=0;
        while(k<lr){
            if(i<l1 && s1[i]==res[k]){
                i++;
            }
            else if(j<l2 && s2[j]==res[k]){
                j++;
            }
            else{
                f=1;
                break;
            }
            k++;
        }
        if(i<l1 || j<l2){
            cout<<"No";
        }
        else{
            cout<<"Yes";
        }
    }
}

// Count and Say

class Solution {
public:
    string countAndSay(int n) {
        if(n==1){
            return "1";
        }
        if(n==2){
            return "11";
        }
        string s="11";
        for(int i=3;i<=n;i++){
            string t="";
            s=s+'&';
            int c=1;
            for(int j=1;j<s.length();j++){
                if(s[j]!=s[j-1]){
                    t=t+to_string(c);
                    t=t+s[j-1];
                    c=1;
                }
                else{
                    c++;
                }
            }
            s=t;
        }
        return s;
    }
};

// Longest plaindrome in a string

string longestPalin (string S) {
        // code here
        int start = 0;
        int end = 1;
        for(int i=1;i<S.size();i++)
        {
            int low = i-1;
            int high = i;
            while(low>=0 && high<S.size()&& S[low]==S[high])
            {
                if(high-low+1>end)
                {
                    start = low;
                    end = high-low+1;
                }

                low--;
                high++;
            }
            low = i-1;
            high = i+1;
            while(low>=0 && high<S.size()&& S[low]==S[high])
            {
                if(high-low+1>end)
                {
                    start = low;
                    end = high-low+1;
                }

                low--;
                high++;
            }

        }

        string ans = "";
        for(int i=start;i<=start+end-1;i++)
        {
            ans = ans+S[i];
        }
   return ans;
}

// Longest Repeating subsequence

class Solution {
    public:
    int LongestRepeatingSubsequence(string str){
        int n = str.size();
        vector <vector <int>> dp(n + 1,vector <int> (n + 1,0));
        for(int i = 1;i <= n;i++){
            for(int j = 1;j <=n;j++){
                if(str[i - 1] == str[j - 1] and i != j){
                    dp[i][j] = 1 + dp[i-1][j-1];
                }
                else{
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[n][n];
    }
};

// Print all subsequences of a string

#include<iostream>
using namespace std;
void func(string str,int start,int n,string s){
    if(start==n){
        cout<<str<<endl;
    }
    else{
        func(str,start+1,n,s);
        str=str+s[start];
        func(str,start+1,n,s);
    }
}
int main(){
    string s;
    cin>>s;
    func("",0,s.length(),s);
    return 0;
}

// Permutations of a given string

(Method-1 => Using next_permutation stl)
class Solution{
	public:
		vector<string>find_permutation(string s)
		{
		    sort(s.begin(),s.end());
            vector<string>ans;
            do{
                ans.push_back(s);
            }
            while(next_permutation(s.begin(),s.end()));
            return ans;
        }
};

(Method-2)
class Solution{
    public:
    void solve(string s,int n,set<string>&st){
        if(n==0){
            st.insert(s);
            return;
        }
        
        for(int i=n;i>=0;i--){
            string temp=s;
            swap(temp[i],temp[n]);
            solve(temp,n-1,st);
        }
    }
    vector<string> find_permutation(string s){
        int n=s.size();
        set<string>st;
            
        solve(s,n-1,st);
        vector<string>ans;
        for(auto i:st){
            ans.push_back(i);
        }
        sort(ans.begin(),ans.end());
        return ans;
    }
};


// Split the binary string into substrings with equal number of 0s and 1s

class Solution {
public:
    int maxSubStr(string str){
        int n= str.length();
        int count=0;
        int ans=0;
        for(int i=0;i<n;i++){
            if(str[i]=='0'){
                count++;    
            } 
            if(str[i]=='1'){
                count--;
            } 
            if(count==0){
                ans++;
            }  
        }
        if(count!=0){
            return -1;    
        } 
        return ans;
    }
};

// Word Wrap

class Solution{
    public:
      int solveWordWrap(vector<int>nums, int k){ 
            int n=nums.size();
            vector<int> dp(n,1000000000);
            int ans[n];
            int cost=0;
            int curlen=0;
            dp[n-1]=0;
            ans[n-1]=n-1;
            for(int i=n-2;i>=0;i--)
            {
                curlen=-1;
                for(int j=i;j<n;j++)
                {
                    curlen+=nums[j]+1;
                    if(curlen>k)
                    break;
                    if(j==n-1)
                    cost=0;
                    else
                    {
                        cost=pow(k-curlen,2)+dp[j+1];
                    }
                    if(cost<dp[i])
                    {
                        dp[i]=cost;
                        ans[i]=j;
                    }
                }
            }
            return dp[0];
        } 
};

// Edit Distance

class Solution{
    public:
    int editDistance(string s, string t)
    {
        int m = s.length();
        int n = t.length();
        vector<vector<int>> dp(m+1, vector<int>(n+1));
        for (int i = 0; i <= m; i++)
        {
            for (int j = 0; j <= n; j++)
            {
                if (i == 0)
                {
                    dp[i][j] = j;
                }
                else if (j == 0)
                {
                    dp[i][j] = i;
                }
                else if (s[i-1] == t[j-1]) 
                {
                    dp[i][j] = dp[i-1][j-1];
                }
                else
                {
                    dp[i][j] = 1 + min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]));
                }
            }
        }
        return dp[m][n];
    }
};

// Next Permutation

class Solution{
public:
    vector<int> nextPermutation(int N, vector<int> arr){
        int i;
        int index=-1;
        for(int i=N-2;i>=0;i--){ // piche se dekho increasing order pe hai array.
           if(arr[i]<arr[i+1]){  // pehle wo index dhundho jahape ye order break ho raha (BREAKPOINT).
               index=i;          // agar nehi mila index to index= -1 hi rahega.
               break;
           }
        }
        // EDGE CASE 
        if(index==-1){   
            reverse(arr.begin(),arr.end()); // nahi mila matlab yeh last permutation hai 
            return arr;                     // so reverse karke return kar do pehla permutation
        }  
        
        for(int i=N-1;i>index;i--){ // ab piche se check karo konsa wala element just
            if(arr[i]>arr[index]){  // greater hai breakpoint wala element se. array
                swap(arr[i],arr[index]); // piche se increasing order main hai. so
                break;  // loop chalake easily find out kar liya konsa just greater hai.
            }  // ab dono element ko swap kardo.
        }
        reverse(arr.begin()+(index+1),arr.end()); // ab jaha pe array ka breakpoint
        return arr;// mila useke baadke index se baki ka array sort ya reverse kar do.
    }
};

// Parenthesis Checker

class Solution
{
    public:
    bool ispar(string x)
    {
        stack<char> st;
        for(int i=0; i < x.length(); i++){
            char a = x[i];
            if(a == '[' || a == '(' || a == '{'){
                st.push(a);
            }
            else{
                if(st.empty()){
                    return false;
                }
                else{
                    char t = st.top(); // for the top element of the stack
                    if(t == '(' && a == ')' || t == '[' && a == ']' || t == '{' && a == '}'){
                        st.pop();
                    }
                    else{
                        return false;
                    }
                }
            }
        }
        return st.empty();
    }
};

// Word Break

class Solution{
public:
// A : given string to search
// B : vector of available strings
    int func(int id,string &A,vector<string> &B){
        string ans = "";
        if(id >= A.size()){
            return 1;
        }
        for(int i = id;i<A.size();i++){
            ans += A[i];
            if(find(B.begin(),B.end(),ans) != B.end()){
                if(1 and func(i+1,A,B)){
                    return true;
                }
            }
        }
        return 0;
    }
    int wordBreak(string A, vector<string> &B) {
       return func(0,A,B);
    }
};

// Rabin-Karp Algorithm

#include <bits/stdc++.h>
using namespace std;

// d is the number of characters in the input alphabet
#define d 256

// pat -> pattern , txt -> text , q -> A prime number 

void search(char pat[], char txt[], int q){
	int M = strlen(pat);
	int N = strlen(txt);
	int i, j;
	int p = 0; // hash value for pattern
	int t = 0; // hash value for txt
	int h = 1; // The value of h would be "pow(d, M-1)%q"
	for (i = 0; i < M - 1; i++)
		h = (h * d) % q;
	// Calculate the hash value of pattern and first window of text
	for (i = 0; i < M; i++) {
		p = (d * p + pat[i]) % q;
		t = (d * t + txt[i]) % q;
	}
	// Slide the pattern over text one by one
	for (i = 0; i <= N - M; i++) {
		// Check the hash values of current window of text and pattern. If the hash values match then only check for characters one by one
		if (p == t) {
			/* Check for characters one by one */
			for (j = 0; j < M; j++) {
				if (txt[i + j] != pat[j]) {
					break;
				}
			}
			// if p == t and pat[0...M-1] = txt[i, i+1,...i+M-1]
			if (j == M)
				cout << "Pattern found at index " << i
					<< endl;
		}
		// Calculate hash value for next window of text: Remove leading digit, add trailing digit
		if (i < N - M) {
			t = (d * (t - txt[i] * h) + txt[i + M]) % q;
			// We might get negative value of t, converting it to positive
			if (t < 0)
				t = (t + q);
		}
	}
}
int main()
{
	char txt[] = "GEEKS FOR GEEKS";
	char pat[] = "GEEK";
	// we mod to avoid overflowing of value but we should take as big q as possible to avoid the collison
	int q = INT_MAX;
	// Function Call
	search(pat, txt, q);
	return 0;
}

// Longest Prefix Suffix(KMP Algorithm)

class Solution{
  public:		
	int lps(string s) {
        int i=0,j=1,k=1,count=0,n=s.size(); // i : string index , j : pattern index
        while(i < n-1 and j < n){
            if(s[i]==s[j]){
                count++;
                i++;
                j++;
            }
            else if(s[i]!=s[j]){
                i=0;
                k++;
                count=0;
                j=k;
            }
        }
        return count;
    }
};

// Convert a sentence into its equivalent mobile numeric keypad sequence

#include <bits/stdc++.h>
using namespace std;
string printSequence(string arr[], string input)
{
    string output = "";
    // length of input string
    int n = input.length();
    for (int i = 0; i < n; i++) {
        // Checking for space
        if (input[i] == ' ')
            output = output + "0";

        else {
            // Calculating index for each character
            int position = input[i] - 'A';
            output = output + arr[position];
        }
    }
    return output;
}
int main()
{
    // storing the sequence in array
    string str[]= { "2",   "22",  "222", "3",   "33",   "333", "4",
                    "44",  "444", "5",   "55",  "555",  "6",   "66",
                    "666", "7",   "77",  "777", "7777", "8",   "88",
                    "888", "9",   "99",  "999", "9999" };
    string input = "GEEKSFORGEEKS";
    cout << printSequence(str, input);
    return 0;
}

// Count the Reversals

int countRev (string s)
{
    if(s.size()%2!=0){
        return -1;
    }
    stack<char> st;
    int c2=0;
    int c1=0;
    for(int i=0;i<s.size();i++){
        if(s[i]=='{'){
            st.push(s[i]);
            c2++;
        }
        else if(s[i]=='}' && !st.empty() && st.top()=='{'){
            st.pop();
            c2--;
        }
        else{
            c1++;
        }
    }
    int ans1 = (c1+1)/2;
    int ans2 = (c2+1)/2;
    return (ans1+ans2);
}

// Count Palindromic Subsequence

class Solution{
    public:
    long long int countPS(string str){
        long long int mod = 1e9 + 7;
        int n = str.size();
        vector<vector<long long int>> dp(n, vector<long long int>(n));
        for (int k = 0; k < n; k++){
            for (int i = 0, j = k + i; i < n and j < n; i++, j++){
                if (i == j)
                    dp[i][j] = 1;
                else if (j == i + 1){
                    if (str[i] == str[j])
                        dp[i][j] = ((dp[i + 1][j]) % mod + (dp[i][j - 1]) % mod + 1) % mod;
                    else
                        dp[i][j] = ((dp[i + 1][j]) % mod + (dp[i][j - 1]) % mod + mod) % mod;
                }
                else{
                    if (str[i] == str[j])
                        dp[i][j] = ((dp[i + 1][j]) % mod + (dp[i][j - 1]) % mod + 1) % mod;
                    else
                        dp[i][j] = ((dp[i + 1][j]) % mod + (dp[i][j - 1]) % mod - (dp[i + 1][j - 1]) % mod + mod) % mod;
                }
            }
        }
        return (dp[0][n - 1]) % mod;
    }
};

// Count of number of given string in 2D character array

#include <bits/stdc++.h>
using namespace std;

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(*a))

int internalSearch(string needle, int row, int col, string hay[], int row_max, int col_max, int xx){
	int found = 0;
	if (row >= 0 && row <= row_max && col >= 0 && col <= col_max && needle[xx] == hay[row][col]){
		char match = needle[xx];
		xx += 1;
		hay[row][col] = 0;
		if (needle[xx] == 0){
			found = 1;
		}
		else{
			// through Backtrack searching in every directions
			found += internalSearch(needle, row, col + 1, hay, row_max, col_max,xx);
			found += internalSearch(needle, row, col - 1, hay, row_max, col_max,xx);
			found += internalSearch(needle, row + 1, col, hay, row_max, col_max,xx);
			found += internalSearch(needle, row - 1, col,hay, row_max, col_max,xx);
		}
		hay[row][col] = match;
	}
	return found;
}

// Function to search the string in 2d array
int searchString(string needle, int row, int col, string str[], int row_count, int col_count)
{
	int found = 0;
	int r, c;
	for (r = 0; r < row_count; ++r)
	{
		for (c = 0; c < col_count; ++c)
		{
			found += internalSearch(needle, r, c, str, row_count - 1, col_count - 1, 0);
		}
	}
	return found;
}

// Driver code
int main()
{
	string needle = "MAGIC";
	string input[] = { "BBABBM","CBMBBA","IBABBG","GOZBBI","ABBBBC","MCIGAM" };
	string str[ARRAY_SIZE(input)];
	int i;
	for (i = 0; i < ARRAY_SIZE(input); ++i){
		str[i] = input[i];
	}
	cout << "count: " << searchString(needle, 0, 0, str, ARRAY_SIZE(str), str[0].size()) << endl;
	return 0;
}

