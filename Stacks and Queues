// Implementation of stack using array

#include<iostream>
#include<stack>
using namespace std;

class Stack{
    // properties
    public:
        int top;
        int *arr;
        int size;
    // behaviour
    Stack(int size){
        this->size=size;
        arr=new int[size];
        top=-1;
    }
    void push(int element){
        if(size-top>1){
            top++;
            arr[top]=element;
        }
        else{
            cout<<"Stack Overflow "<<endl;
        }
    }
    int peek(){
        if(top>=0){
            return arr[top];
        }
        else{
            cout<<"Stack is empty "<<endl;
            return -1;
        }
    }
    void pop(){
        if(top>=0){
            top--;
        }
        else{
            cout<<"Stack UnderFlow "<<endl;
        }
    }
    bool isEmpty(){
        if(top==-1){
            return true;
        }
        else{
            return false;
        }
    }
};
int main(){
    /* 
    stack<int> s;
    s.push(2);
    s.push(1);
    s.push(3);
    s.pop();
    cout<<"printing top element "<<s.top()<<endl;
    if(s.empty()){
        cout<<"Stack is empty "<<endl;
    }
    else{
        cout<<"Stack is not empty "<<endl;
    }
    cout<<"Size of the stack is: "<<s.size()<<endl; 
    */
    Stack st(5);
    st.push(10);
    st.push(3);
    st.push(7);
    cout<<"Peek element is: "<<st.peak()<<endl;
    st.pop();
    cout<<"Peek element is: "<<st.peak()<<endl;
    cout<<"Empty or not: "<<st.isEmpty()<<endl;
    return 0;
}

// Implementation of stack using Linked list

#include <bits/stdc++.h>
using namespace std;
// creating a linked list;
class Node {
public:
	int data;
	Node *link;
	// Constructor
	Node(int n){
		this->data = n;
		this->link = NULL;
	}
};
class Stack {
	Node *top;
    public:
	Stack() { 
        top = NULL; 
    }
	void push(int data){
		// Create new node temp and allocate memory in heap
		Node* temp = new Node(data);
		// Check if stack (heap) is full. Then inserting an element would lead to stack overflow
		if (!temp) {
			cout << "\nStack Overflow";
			exit(1);
		}
		// Initialize data into temp data field
		temp->data = data;
		// Put top pointer reference into temp link
		temp->link = top;
		// Make temp as top of Stack
		top = temp;
	}
	// Utility function to check if the stack is empty or not
	bool isEmpty(){
		// If top is NULL it means that there are no elements are in stack
		return top == NULL;
	}
	// Utility function to return top element in a stack
	int peek(){
		// If stack is not empty , return the top element
		if (!isEmpty())
			return top->data;
		else
			exit(1);
	}
	// Function to remove a key from given queue q
	void pop(){
		Node* temp;
		// Check for stack underflow
		if (top == NULL) {
			cout << "\nStack Underflow" << endl;
			exit(1);
		}
		else {
			// Assign top to temp
			temp = top;
			// Assign second node to top
			top = top->link;
			// This will automatically destroy the link between first node and second node
			// Release memory of top node i.e delete the node
			free(temp);
		}
	}
	// Function to print all the elements of the stack
	void display(){
		Node* temp;
		// Check for stack underflow
		if (top == NULL) {
			cout << "\nStack Underflow";
			exit(1);
		}
		else {
			temp = top;
			while (temp != NULL) {
				// Print node data
				cout << temp->data;
				// Assign temp link to temp
				temp = temp->link;
				if (temp != NULL)
					cout << " -> ";
			}
		}
	}
};
int main(){
	// Creating a stack
	Stack s;
	// Push the elements of stack
	s.push(11);
	s.push(22);
	s.push(33);
	s.push(44);
	// Display stack elements
	s.display();
	// Print top element of stack
	cout << "\nTop element is " << s.peek() << endl;
	// Delete top elements of stack
	s.pop();
	s.pop();
	// Display stack elements
	s.display();
	// Print top element of stack
	cout << "\nTop element is " << s.peek() << endl;
	return 0;
}

// Implementation of queue using array

// Actual ans
void MyQueue :: push(int x)
{
    if(rear == 100005)
        return;
    arr[rear] = x;
        rear++;    
}
//Function to pop an element from queue and return that element.
int MyQueue :: pop()
{
    if(rear == front)
        return -1;
    int val = arr[front];
    front++;
    return val;           
}

// everything
class MyQueue {
    int front, rear;
    int arr[] = new int[100005];
    int capacity = arr.length;
    MyQueue()
    {
        front=0;
        rear=0;
    }
    
    //Function to push an element x in a queue.
    void push(int x)
    {
        if(!isFull())
        {
            arr[rear] = x;
            rear++;
        }
    } 

    //Function to pop an element from queue and return that element.
    int pop()
    {
        int temp = -1;
        if(!isEmpty())
        {
            temp = arr[front];
            front++;
        }
        return temp;
    }
    
    boolean isEmpty()
    {
        if(front==rear)
        {
            return true;
        }
        return false;
    }
    boolean isFull()
    {
        if(rear==capacity)
        {
            return true;
        }
        return false;
    }
}

// Implement two stacks in an array

//Function to push an integer into the stack1.
void twoStacks :: push1(int x)
{
    if(top2-top1>1){
        top1++;
        arr[top1]=x;
    }
}  
//Function to push an integer into the stack2.
void twoStacks ::push2(int x)
{
    if(top2-top1>1){
        top2--;
        arr[top2]=x;
    }
}  
//Function to remove an element from top of the stack1.
int twoStacks ::pop1()
{
    if(top1>=0){
        int ans=arr[top1];
        top1--;
        return ans;
    }
    else{
        return -1;
    }
}
//Function to remove an element from top of the stack2.
int twoStacks :: pop2()
{
    if(top2<size){
        int ans=arr[top2];
        top2++;
        return ans;
    }
    else{
        return -1;
    }
}

// Design a stack with operations on middle element

// Method-1
#include <bits/stdc++.h>
using namespace std;
class myStack {
	struct Node {
		int num;
		Node* next;
		Node* prev;

		Node(int num) { this->num = num; }
	};
	// Members of stack
	Node* head = NULL;
	Node* mid = NULL;
	int size = 0;
public:
	void push(int data)
	{
		Node* temp = new Node(data);
		if (size == 0) {
			head = temp;
			mid = temp;
			size++;
			return;
		}
		head->next = temp;
		temp->prev = head;

		// update the pointers
		head = head->next;
		if (size % 2 == 1) {
			mid = mid->next;
		}
		size++;
	}
	int pop()
	{
	int data=-1;
		if (size != 0) {
		Node* toPop = head;
		data = toPop->num;
			if (size == 1) {
				head = NULL;
				mid = NULL;
			}
			else {
				head = head->prev;
				head->next = NULL;
				if (size % 2 == 0) {
					mid = mid->prev;
				}
			}
			delete toPop;
			size--;
		}
	return data;
	}
	int findMiddle()
	{
		if (size == 0) {
			return -1;
		}
		return mid->num;
	}
	void deleteMiddle()
	{
		if (size != 0) {
			Node* toDelete = mid;
			if (size == 1) {
				head = NULL;
				mid = NULL;
			}
			else if (size == 2) {
				head = head->prev;
				mid = mid->prev;
				head->next = NULL;
			}
			else {
				mid->next->prev = mid->prev;
				mid->prev->next = mid->next;
				if (size % 2 == 0) {
					mid = mid->prev;
				}
				else {
					mid = mid->next;
				}
			}
			delete toDelete;
			size--;
		}
	}
};
int main()
{
	myStack st;
	st.push(11);
	st.push(22);
	st.push(33);
	st.push(44);
	st.push(55);
	st.push(66);
	st.push(77);
	st.push(88);
	st.push(99);
	cout <<"Popped : "<< st.pop() << endl;
	cout <<"Popped : "<< st.pop() << endl;
	cout <<"Middle Element : "<< st.findMiddle() << endl;
	st.deleteMiddle();
	cout <<"New Middle Element : "<< st.findMiddle() << endl;
	return 0;
}

// Method-2

#include <bits/stdc++.h>
using namespace std;
class myStack {
	stack<int> st;
	deque<int> dq;
public:
	void add(int data)
	{
		dq.push_back(data);
		if (dq.size() > st.size() + 1) {
			int temp = dq.front();
			dq.pop_front();
			st.push(temp);
		}
	}
	void pop()
	{
		int data = dq.back();
		dq.pop_back();
		if (st.size() > dq.size()) {
			int temp = st.top();
			st.pop();
			dq.push_front(temp);
		}
	}
	int getMiddleElement() {
	return dq.front();
	}
	void deleteMiddleElement()
	{
		dq.pop_front();
		if (st.size() > dq.size()) { // new middle element
			int temp = st.top();	 // should come at front of deque
			st.pop();
			dq.push_front(temp);
		}
	}
};
int main()
{
	myStack st;
	st.add(2);
	st.add(5);
	cout << "Middle Element: " << st.getMiddleElement() << endl;
	st.add(3);
	st.add(7);
	st.add(4);
	cout << "Middle Element: " << st.getMiddleElement() << endl;
	st.deleteMiddleElement();
	cout << "Middle Element: " << st.getMiddleElement() << endl;
	st.deleteMiddleElement();
	cout << "Middle Element: " << st.getMiddleElement() << endl;
	st.pop();
	st.pop();
	st.deleteMiddleElement();
}

// How to efficiently implement k stacks in a single array?( https://www.geeksforgeeks.org/efficiently-implement-k-stacks-single-array/ )

// Implementation of k stacks in a single
#include<bits/stdc++.h>
using namespace std;
// A C++ class to represent k stacks in a single array of size n
class kStacks{
	int *arr; // Array of size n to store actual content to be stored in stacks
	int *top; // Array of size k to store indexes of top elements of stacks
	int *next; // Array of size n to store next entry in all stacks
				// and free list
	int n, k;
	int free; // To store beginning index of free list
public:
	//constructor to create k stacks in an array of size n
	kStacks(int k, int n);
	// A utility function to check if there is space available
	bool isFull() { return (free == -1); }
	// To push an item in stack number 'sn' where sn is from 0 to k-1
	void push(int item, int sn);
	// To pop an from stack number 'sn' where sn is from 0 to k-1
	int pop(int sn);
	// To check whether stack number 'sn' is empty or not
	bool isEmpty(int sn) { return (top[sn] == -1); }
};
//constructor to create k stacks in an array of size n
kStacks::kStacks(int k1, int n1)
{
	// Initialize n and k, and allocate memory for all arrays
	k = k1, n = n1;
	arr = new int[n];
	top = new int[k];
	next = new int[n];
	// Initialize all stacks as empty
	for (int i = 0; i < k; i++)
		top[i] = -1;
	// Initialize all spaces as free
	free = 0;
	for (int i=0; i<n-1; i++)
		next[i] = i+1;
	next[n-1] = -1; // -1 is used to indicate end of free list
}
// To push an item in stack number 'sn' where sn is from 0 to k-1
void kStacks::push(int item, int sn)
{
	// Overflow check
	if (isFull())
	{
		cout << "\nStack Overflow\n";
		return;
	}
	int i = free;	 // Store index of first free slot
	// Update index of free slot to index of next slot in free list
	free = next[i];
	// Update next of top and then top for stack number 'sn'
	next[i] = top[sn];
	top[sn] = i;
	// Put the item in array
	arr[i] = item;
}
// To pop an element from stack number 'sn' where sn is from 0 to k-1
int kStacks::pop(int sn)
{
	// Underflow check
	if (isEmpty(sn))
	{
		cout << "\nStack Underflow\n";
		return INT_MAX;
	}
	// Find index of top item in stack number 'sn'
	int i = top[sn];
	top[sn] = next[i]; // Change top to store next of previous top
	// Attach the previous top to the beginning of free list
	next[i] = free;
	free = i;
	// Return the previous top item
	return arr[i];
}
/* Driver program to test twoStacks class */
int main()
{
	// Let us create 3 stacks in an array of size 10
	int k = 3, n = 10;
	kStacks ks(k, n);
	// Let us put some items in stack number 2
	ks.push(15, 2);
	ks.push(45, 2);
	// Let us put some items in stack number 1
	ks.push(17, 1);
	ks.push(49, 1);
	ks.push(39, 1);
	// Let us put some items in stack number 0
	ks.push(11, 0);
	ks.push(9, 0);
	ks.push(7, 0);
	cout << "Popped element from stack 2 is " << ks.pop(2) << endl;
	cout << "Popped element from stack 1 is " << ks.pop(1) << endl;
	cout << "Popped element from stack 0 is " << ks.pop(0) << endl;
	return 0;
}

// Parenthesis Checker

class Solution
{
    public:
    bool ispar(string x)
    {
        stack<char> st;
        for(int i=0; i < x.length(); i++){
            char a = x[i];
            if(a == '[' || a == '(' || a == '{'){
                st.push(a);
            }
            else{
                if(st.empty()){
                    return false;
                }
                else{
                    char t = st.top(); // for the top element of the stack
                    if(t == '(' && a == ')' || t == '[' && a == ']' || t == '{' && a == '}'){
                        st.pop();
                    }
                    else{
                        return false;
                    }
                }
            }
        }
        return st.empty();
    }
};

// Reverse a string using stack

char* reverse(char *S, int len){
    stack<char> st;
    for(int i = 0;i<len;i++){
        st.push(S[i]);
    }
    int i = 0;
    while(!st.empty()){
        S[i++] = st.top();
        st.pop();
    }
    return S;
}

// Special Stack

#include<limits.h>
void push(stack<int>& s, int a){
    s.push(a);
}
bool isFull(stack<int>& s,int n){
    if(s.size() == n)
    {
        return true;
    }
    return false;
}
bool isEmpty(stack<int>& s){
    if(s.empty())
    {
        return true;
    }
    return false;
}
int pop(stack<int>& s){
    if(s.empty())
    {
        return -1;
    }
    else 
    {
        int x = s.top();
        s.pop();
        return x;
    }
}
int getMin(stack<int>& s){
    if(s.empty())
    {
        return INT_MAX;
    }
    int x= s.top();
    s.pop();
    int y = getMin(s);
    s.push(x);
    return min(x,y);
}

// Next greater element

class Solution{
    public:
    vector<long long> nextLargerElement(vector<long long> arr, int n) {
        stack<long long>st;
        vector<long long> ans(n); 
        for(int i=n-1;i>=0;i--){
            while(!st.empty() && arr[i]>=st.top()){
                st.pop();
            }
            if(st.empty()){
                ans[i]=-1;
            }
            else{
                ans[i]=st.top();
            }
            st.push(arr[i]);
        }
        return ans;
    }
};

// Celebrity problem

class Solution 
{
    private:
    bool knows(vector<vector<int> >& M, int a, int b, int n) {
        if(M[a][b] == 1)
            return true;
        else
            return false;
    }
    public:
    int celebrity(vector<vector<int> >& M, int n) 
    {
        stack<int> s;
        //step1: push all element in stack
        for(int i=0; i<n; i++) {
            s.push(i);
        }   
        //step2: get 2 elements and copare them
        while(s.size() > 1) {
            int a = s.top();
            s.pop();
            int b = s.top();
            s.pop();
            if(knows(M,a,b,n)){
                s.push(b);
            }
            else
            {
                s.push(a);
            }
        }
        int ans = s.top();
        //step3: single element in stack is potential celeb
        //so verify it
        int zeroCount = 0;
        for(int i=0; i<n; i++) {
            if(M[ans][i] == 0)
                zeroCount++;
        }
        //all zeroes
        if(zeroCount != n)
            return -1;
        //column check
        int oneCount = 0;
        for(int i=0; i<n; i++) {
            if(M[i][ans] == 1)
                oneCount++;
        }
        if(oneCount != n-1)
            return -1;
        return ans;
    }
};

// Arithmetic Expression Evaluation ( https://www.geeksforgeeks.org/arithmetic-expression-evalution/ )

// Evaluation of prefix expression

// Method-1
#include <bits/stdc++.h>
using namespace std;
bool isOperand(char c)
{
	// If the character is a digit then it must be an operand
	return isdigit(c);
}
double evaluatePrefix(string exprsn)
{
	stack<double> Stack;
	for (int j = exprsn.size() - 1; j >= 0; j--) {
		// Push operand to Stack To convert exprsn[j] to digit subtract '0' from exprsn[j].
		if (isOperand(exprsn[j]))
			Stack.push(exprsn[j] - '0');
		else {
			// Operator encountered Pop two elements from Stack
			double o1 = Stack.top();
			Stack.pop();
			double o2 = Stack.top();
			Stack.pop();
			// Use switch case to operate on o1 and o2 and perform o1 Or o2.
			switch (exprsn[j]) {
			case '+':
				Stack.push(o1 + o2);
				break;
			case '-':
				Stack.push(o1 - o2);
				break;
			case '*':
				Stack.push(o1 * o2);
				break;
			case '/':
				Stack.push(o1 / o2);
				break;
			}
		}
	}
	return Stack.top();
}
int main()
{
	string exprsn = "+9*26";
	cout << evaluatePrefix(exprsn) << endl;
	return 0;
}

// Method-2
#include <bits/stdc++.h>
using namespace std;
double evaluatePrefix(string exprsn)
{
    stack<double> Stack;
    for (int j = exprsn.size() - 1; j >= 0; j--) {
        // if jth character is the delimiter ( which is space in this case) then skip it
        if (exprsn[j] == ' ')
            continue;
        // Push operand to Stack To convert exprsn[j] to digit subtract '0' from exprsn[j].
        if (isdigit(exprsn[j])) {
            // there may be more than one digits in a number
            double num = 0, i = j;
            while (j < exprsn.size() && isdigit(exprsn[j]))
                j--;
            j++;
            // from [j, i] exprsn contains a number
            for (int k = j; k <= i; k++)
                num = num * 10 + double(exprsn[k] - '0');
 
            Stack.push(num);
        }
        else {
            // Operator encountered Pop two elements from Stack
            double o1 = Stack.top();
            Stack.pop();
            double o2 = Stack.top();
            Stack.pop();
            // Use switch case to operate on o1 and o2 and perform o1 O o2.
            switch (exprsn[j]) {
            case '+':
                Stack.push(o1 + o2);
                break;
            case '-':
                Stack.push(o1 - o2);
                break;
            case '*':
                Stack.push(o1 * o2);
                break;
            case '/':
                Stack.push(o1 / o2);
                break;
            }
        }
    }
    return Stack.top();
}
int main()
{
    string exprsn = "+ 9 * 12 6";
    cout << evaluatePrefix(exprsn) << endl;
    return 0;
}

// Evaluation of Postfix Expression

class Solution
{
    public:
    int evaluatePostfix(string S)
    {
        stack<int> st;
        for(int i=0;i<S.length();i++)
        {
            if(S[i] == '*' || S[i] == '/' || S[i] == '+' || S[i] == '-')
            {
                int a = st.top();
                st.pop();
                int b = st.top();
                st.pop();
                int c;
                if(S[i] == '*')
                    c = a*b;
                else if(S[i] == '/')
                    c = b/a;
                else if(S[i] == '+')
                    c = a+b;
                else if(S[i] == '-')
                    c = b-a;
                
                st.push(c);
            }
            else
                st.push(int(S[i]) - 48);
        }
        return st.top();      
    }
};

// Inserting at the bottom of stack

#include <bits/stdc++.h>
void solve(stack<int> &s,int x){
    if(s.empty()){
        s.push(x);
        return;
    }
    int num=s.top();
    s.pop();
    solve(s,x);
    s.push(num);
} 
stack<int> pushAtBottom(stack<int>& myStack, int x) {
    solve(myStack,x);
    return myStack;    
}

// How to Reverse a Stack using Recursion

class Solution{
    public:
    void Reverse(stack<int> &St){
       vector<int> s1;
       while(!St.empty()){
           int num=St.top();
           St.pop();
           s1.push_back(num);
       }
       for(int i=0;i<s1.size();i++){
           St.push(s1[i]);
       }
    }
};

// Sort a stack

void sortedInsert(stack<int>& s,int num){
    if(s.empty()|| s.top()<num){
        s.push(num);
        return;
    }
    int n=s.top();
    s.pop();
    sortedInsert(s,num);
    s.push(n);   
}
void SortedStack :: sort()
{
   if(s.empty()){
       return;
   }
   int num=s.top();
   s.pop();
   sort();
   sortedInsert(s,num);
}

// Merge overlapping intervals

// Method-1
class Solution {
public:
    vector<vector<int>> overlappedInterval(vector<vector<int>>& intervals) {

         sort(intervals.begin() , intervals.end()) ; 
         int n = intervals.size() ; 
         int res = 0 ; 
         for(int i = 1 ; i<n ; i++){
             if(intervals[res][1] >= intervals[i][0]){
                 intervals[res][1] = max( intervals[res][1] ,  intervals[i][1]);
                 intervals[res][0] = min( intervals[res][0] ,  intervals[i][0]) ;
             }
             else{
                 res++;
                 intervals[res] = intervals[i] ; 
             }
         }
         intervals.resize(res+1) ; 
         return intervals ; 
    }
};

// Method-2
  vector<vector<int>> merge(vector<vector<int>>& intervals) {
        //sort intervals in order to get the overlapping ones consecutively
        sort(intervals.begin(),intervals.end());
        //this will store the non overlapping intervals
        stack<vector<int>>st;
        //firstly push the 0th interval
        st.push(intervals[0]);
        //start from the 1st till the last interval 
        for(int i=1;i<intervals.size();i++)
        {
            //extract the ith interval in v vector
            vector<int>v=intervals[i];
            //get the interval at top of the stack in t vector
            vector<int>t=st.top();
            //check if interval in v overlaps with interval in t
            if(!st.empty()&&v[0]>=t[0]&&v[0]<=t[1])
            {
                //if yes then remove the interval stored in stack 
                st.pop();
                //make a new interval which includes both overlapping intervals
                vector<int>a;
                //start of interval will be t[0] becoz v[0] will lie "between" t[0] and t[1]
                a.push_back(t[0]);
                //end of the interval will be max of v[1] or t[1] as v[0] lies in between and the v[1] and t[1] are the end of both intervals hence the one which is greater will be considered
                a.push_back(max(v[1],t[1]));
                //push the overlapped interval in the stack now
                st.push(a);
            }
            //if there is no overlapping then simply push the vector to the stack
            else
                st.push(v);
        }
        //in order to store the new intervals stored in stack remove old ones
        intervals.clear();
        //traverse the stack untill it is empty
        while(!st.empty())
        {
            //add the new intervals in the vector
            intervals.push_back(st.top());
            st.pop();
        }
        //return the vector having new intervals!
        return intervals;
}

// Maximum Rectangle area in histogram

class Solution
{
    public:
    long long getMaxArea(long long arr[], int n)
    {
        stack<long long> s;
        long long maxArea= INT_MIN;
        for(int i=0;i<=n;i++){
            while(!s.empty()&&(i==n||arr[s.top()]>=arr[i])){
                long long hgh=arr[s.top()];
                s.pop();
                long long wdt;
                if(s.empty()) wdt=i;
                else wdt = i-s.top()-1;
                maxArea=max(maxArea,hgh*wdt);
            }
            s.push(i);
        }
        return maxArea;
    }
};

// Valid Substring

class Solution {
  public:
    int findMaxLen(string s) {
        stack<int> st;
        for(int i = 0;i<s.length();i++)
        {
            if(s[i] == '(')
            {
                st.push(i);
            }
            else 
            {
                if(!st.empty() && s[st.top()] == '(')
                {
                    st.pop();
                }
                else 
                {
                    st.push(i);
                }
            }
        }
        int result = 0;
        int lastIndex = s.length();
        while(!st.empty())
        {
            int top = st.top();
            st.pop();
            result = max(result , lastIndex-top-1);
            lastIndex = top;
        }
        return max(result , lastIndex);
    }
};

// Expression contains redundant bracket or not

#include <bits/stdc++.h> 
bool findRedundantBrackets(string &s)
{
    stack<char> st;
    for(int i=0;i<s.length();i++){
        char ch=s[i];
        if(ch=='(' || ch=='+' || ch=='-' || ch=='*' || ch=='/' ){
            st.push(ch);
        }
        else{
            if(ch==')'){
                bool isRedundant=true;
                while(st.top()!='('){
                    char top=st.top();
                    if(top=='+' || top=='-' || top=='*' || top=='/' ){
                        isRedundant=false;
                    }
                    st.pop();
                }
                if(isRedundant==true){
                    return true;
                }
                st.pop();
            }
        }
    }
    return false;
}

// Stack using one queue

void QueueStack :: push(int x){
        q1.push(x);
        int n=q1.size();
        for(int i=0;i<n-1;i++){
            int y = q1.front();
            q1.pop();
            q1.push(y);
        }
}
int QueueStack :: pop(){
        if(q1.empty())
            return -1;
        int x = q1.front();
        q1.pop();
        return x;
}

// Stack using two queues

void QueueStack :: push(int x)
{
        q2.push(x);
        while(!q1.empty()){
            q2.push(q1.front());
            q1.pop();
        }
        swap(q1,q2);
}
int QueueStack :: pop()
{
        if(q1.empty())
        return -1;
        int ans = q1.front();
        q1.pop();
        return ans;
}

// Implement Stack and Queue using Deque

#include <bits/stdc++.h>
using namespace std;
// structure for a node of deque
struct DQueNode {
	int value;
	DQueNode* next;
	DQueNode* prev;
};
// Implementation of deque class
class Deque {
private:
	// pointers to head and tail of deque
	DQueNode* head;
	DQueNode* tail;
public:
	// constructor
	Deque()
	{
		head = tail = NULL;
	}
	// if list is empty
	bool isEmpty()
	{
		if (head == NULL)
			return true;
		return false;
	}
	// count the number of nodes in list
	int size()
	{
		// if list is not empty
		if (!isEmpty()) {
			DQueNode* temp = head;
			int len = 0;
			while (temp != NULL) {
				len++;
				temp = temp->next;
			}
			return len;
		}
		return 0;
	}
	// insert at the first position
	void insert_first(int element)
	{
		// allocating node of DQueNode type
		DQueNode* temp = new DQueNode[sizeof(DQueNode)];
		temp->value = element;
		// if the element is first element
		if (head == NULL) {
			head = tail = temp;
			temp->next = temp->prev = NULL;
		}
		else {
			head->prev = temp;
			temp->next = head;
			temp->prev = NULL;
			head = temp;
		}
	}
	// insert at last position of deque
	void insert_last(int element)
	{
		// allocating node of DQueNode type
		DQueNode* temp = new DQueNode[sizeof(DQueNode)];
		temp->value = element;
		// if element is the first element
		if (head == NULL) {
			head = tail = temp;
			temp->next = temp->prev = NULL;
		}
		else {
			tail->next = temp;
			temp->next = NULL;
			temp->prev = tail;
			tail = temp;
		}
	}
	// remove element at the first position
	void remove_first()
	{
		// if list is not empty
		if (!isEmpty()) {
			DQueNode* temp = head;
			head = head->next;
			if(head) head->prev = NULL;
			delete temp;
			if(head == NULL) tail = NULL;
			return;
		}
		cout << "List is Empty" << endl;
	}
	// remove element at the last position
	void remove_last()
	{
		// if list is not empty
		if (!isEmpty()) {
			DQueNode* temp = tail;
			tail = tail->prev;
			if(tail) tail->next = NULL;
			delete temp;
			if(tail == NULL) head = NULL;
			return;
		}
		cout << "List is Empty" << endl;
	}
	// displays the elements in deque
	void display()
	{
		// if list is not empty
		if (!isEmpty()) {
			DQueNode* temp = head;
			while (temp != NULL) {
				cout << temp->value << " ";
				temp = temp->next;
			}
			cout << endl;
			return;
		}
		cout << "List is Empty" << endl;
	}
};
// Class to implement stack using Deque
class Stack : public Deque {
public:
	// push to push element at top of stack using insert at last function of deque
	void push(int element)
	{
		insert_last(element);
	}
	// pop to remove element at top of stack using remove at last function of deque
	void pop()
	{
		remove_last();
	}
};
// class to implement queue using deque
class Queue : public Deque {
public:
	// enqueue to insert element at last using insert at last function of deque
	void enqueue(int element)
	{
		insert_last(element);
	}
	// dequeue to remove element from first using remove at first function of deque
	void dequeue()
	{
		remove_first();
	}
};
int main()
{
	// object of Stack
	Stack stk;
	// push 7 and 8 at top of stack
	stk.push(7);
	stk.push(8);
	cout << "Stack: ";
	stk.display();
	// pop an element
	stk.pop();
	cout << "Stack: ";
	stk.display();
	// object of Queue
	Queue que;
	// insert 12 and 13 in queue
	que.enqueue(12);
	que.enqueue(13);
	cout << "Queue: ";
	que.display();
	// delete an element from queue
	que.dequeue();
	cout << "Queue: ";
	que.display();
	cout << "Size of Stack is " << stk.size() << endl;
	cout << "Size of Queue is " << que.size() << endl;
	return 0;
}

// Stack Permutations (Check if an array is stack permutation of other)

class Solution{
public:
    int isStackPermutation(int N,vector<int> &A,vector<int> &B){
        stack<int> stk; int j = 0;
        for(int i = 0; i < N; i++) {
            stk.push(A[i]);
            while(!stk.empty() and j < N and stk.top() == B[j]) 
                stk.pop(), j++;
        }
        while(!stk.empty() and j < N and stk.top() == B[j])
            stk.pop(), j++;
        return stk.empty();
    }
};

// Queue using two Stacks

//Function to push an element in queue by using 2 stacks.
void StackQueue :: push(int x)
{
    s1.push(x);
}
//Function to pop an element from queue by using 2 stacks.
int StackQueue :: pop()
{
        int n=s1.size();
        if( n==0)  return -1;
        int i=1;
        while(i<n){
            s2.push(s1.top());
            s1.pop();
            i++;
        }
        int res=s1.top();
        s1.pop();
        while(!s2.empty()){
            s1.push(s2.top());
            s2.pop();
        }
        return res;
}

// How to efficiently implement k Queues in a single array? ( https://www.geeksforgeeks.org/efficiently-implement-k-queues-single-array/ )

#include <iostream>
#include <queue>
using namespace std;
class kQueue
{
public:
    int n;
    int k;
    int *arr;
    int *front;
    int *rear;
    int freespot;
    int *next;

public:
    kQueue(int n, int k)
    {
        this->n = n;
        this->k = k;
        front = new int[k];
        rear = new int[k];
        for (int i = 0; i < k; i++)
        {
            front[i] = -1;
            rear[i] = -1;
        }
        next = new int[n];
        for (int i = 0; i < n; i++)
        {
            next[i] = i + 1;
        }
        next[n - 1] = -1;
        arr = new int[n];
        freespot = 0;
    }
    void enqueue(int data,int qn){
        // overflow
        if(freespot==-1){
            cout<<"No empty space is present "<<endl;
            return;
        }
        // find first free index
        int index=freespot;
        // update freespot
        freespot=next[index];
        // check whether first element
        if(front[qn-1]==-1){
            front[qn-1]=index;
        }
        // link new element to the previous element
        else{
            next[rear[qn-1]]=index;
        } 
        // update next
        next[index]=-1;
        // update rear
        rear[qn-1]=index;
        // push element
        arr[index]=data;
    }
    int dequeue(int qn){
        // underflow
        if(front[qn-1]==-1){
            cout<<"Queue underflow"<<endl;
            return -1;
        }
        // find index to pop
        int index=front[qn-1];
        // front ko aage badhao
        front[qn-1]=next[index];
        // freeslots ko manage karo
        next[index]=freespot;
        freespot=index;
        return arr[index];
    }
};
int main()
{
    kQueue q(10,3);
    q.enqueue(10,1);
    q.enqueue(15,1);
    q.enqueue(20,2);
    q.enqueue(25,1);
    // cout<<q.dequeue(1)<<endl;
    // cout<<q.dequeue(2)<<endl;
    // cout<<q.dequeue(1)<<endl;
    // cout<<q.dequeue(1)<<endl; // output -> 10 20 15 25
    cout<<q.dequeue(1)<<endl;
    cout<<q.dequeue(2)<<endl;
    cout<<q.dequeue(1)<<endl;
    cout<<q.dequeue(1)<<endl;
    cout<<q.dequeue(1)<<endl; // output -> 10 20 15 25 Queue underflow -1
    return 0;
}

// Introduction to Circular Queue

// Circular Queue using array
#include <bits/stdc++.h> 
class CircularQueue{
    int size;
    int front;
    int rear;
    int *arr;
    public:
    CircularQueue(int n){
        size = n;
        arr = new int[size];
        front = -1;
        rear  =  -1;
    }
    // Enqueues 'X' into the queue. Returns true if it gets pushed into the stack, and false otherwise.
    bool enqueue(int value){
        if((front==0 && rear==size-1) || (rear == (front-1)%(size-1))){
            return false;
        }
        else if(front==-1){
            front=0; 
            rear=0;
        }
        else if(rear==size-1 && front!=0){
            rear = 0;
        }
        else{
            rear++;
        }
        arr[rear] = value;
        return true;
    }
    // Dequeues top element from queue. Returns -1 if the stack is empty, otherwise returns the popped element.
    int dequeue(){
        if(front==-1){
            return -1;
        }
        int ans=arr[front];
        arr[front]=-1;
        if(front==rear){
            front=-1;
            rear=-1;
        }
        else if(front==size-1){
            front=0;
        }
        else{
            front++;
        }
        return ans;
    }
};

// Circular queue using linked list

class MyCircularQueue {
public:
    int head, tail, size;
    vector<int> q;
    MyCircularQueue(int k) : head(-1), tail(-1), size(k), q(k) {}
    bool enQueue(int value) {
        if (isFull()) return false;
        if (tail == -1) head = tail = 0;
        else tail = (tail+1) % size;
        q[tail] = value;
        return true;
    }
    bool deQueue() {
        if (isEmpty()) return false;
        if (head == tail) head = tail = -1;
        else head = (head+1) % size;
        return true;
    }
    int Front() {
        return (isEmpty()) ? -1 : q[head];
    }
    int Rear() {
        return (isEmpty()) ? -1 : q[tail];
    }
    bool isEmpty() {
        return (head == -1);
    }
    bool isFull() {
        return ((head == 0 && tail == size-1) || (tail == head-1)); 
    }
};

// LRU cache

class LRUCache
{
    public:
    class node{
        public:
        int key,value;
        node* next;
        node* prev;
        node(int x,int y){
            next=NULL;
            prev=NULL;
            key=x;
            value=y;
        }
    };
    node* head=new node(-1,-1);
    node* tail=new node(-1,-1);
    void addnode(int x,int y){
        node* ptr= new node(x,y);
        ptr->next=head->next;
        head->next->prev=ptr;
        head->next=ptr;
        ptr->prev=head;
    }
    void delnode(node* ptr)
    {
        ptr->prev->next=ptr->next;
        ptr->next->prev=ptr->prev;
        delete ptr;
    }
    int size;
    unordered_map <int,node*> mp;
    LRUCache(int cap)
    {
        size=cap;
        head->next=tail;
        tail->prev=head;
       
    }
    //Function to return value corresponding to the key.
    int GET(int key)
    {
        if (mp.find(key) != mp.end())
        {
            addnode(key,mp[key]->value);
            delnode(mp[key]);
            mp[key]=head->next;
            return head->next->value;
        }
        else{
        return -1;}
    }
    //Function for storing key-value pair.
    void SET(int key, int value)
    {
        if(mp.size()==size)
        {
            if(mp.find(key) != mp.end())
            {
               mp[key]->value=value;
               delnode(mp[key]);
               addnode(key,value);
               mp[key]=head->next;
            }
            else{
            mp.erase(tail->prev->key);
            delnode(tail->prev);
            addnode(key,value);
            mp.insert({key,head->next});
            }
        }
        else{
            if(mp.find(key) != mp.end())
            {
               mp[key]->value=value;
               delnode(mp[key]);
               addnode(key,value);
               mp[key]=head->next;
            }
            else{
            addnode(key,value);
            mp.insert({key,head->next});
            }
        }
    }
};

// Queue reversal

queue<int> rev(queue<int> q)
{
    stack<int> s;
    while(!q.empty()){
        int element=q.front();
        q.pop();
        s.push(element);
    }
    while(!s.empty()){
        int element=s.top();
        s.pop();
        q.push(element);
    }
    return q;
}

// Reverse first k elements of queue

queue<int> modifyQueue(queue<int> q, int k) {
    //algo:
    //first k element stack me daaldo  and queue se hatado
    // k element stack se nikalke wapas queue me daalde 
    // fer queue k (n-k) starting k elements, wapas queue me daalde
    stack<int> s;
    for(int i = 0; i<k; i++) {
        int val = q.front();
        q.pop();
        s.push(val);
    }
    while(!s.empty()) {
        int val = s.top();
        s.pop();
        q.push(val);
    }
    int t = q.size()-k;
    while(t--) {
        int val = q.front();
        q.pop();
        q.push(val);
    }
    return q;
}

// Interleave the firt half of the queue with the second half

// Method-1
#include <bits/stdc++.h> 
void interLeaveQueue(queue < int > & q) {
    queue<int> newq;
    int n=q.size()/2;
    while(n--){
        newq.push(q.front());
        q.pop();
    }
    while(!newq.empty()){
        q.push(newq.front());
        newq.pop();
        int ele=q.front();
        q.pop();
        q.push(ele);
    }
}

// Method-2
#include <bits/stdc++.h> 
void interLeaveQueue(queue < int > & q) {
    stack<int> s;
    int n=q.size()/2;
    int count=0;
    while(count<n){
        s.push(q.front());
        q.pop();
        count++;
    }
    while(!s.empty()){
        q.push(s.top());
        s.pop();
    }
    count=0;
    while(count<n){
        int ele=q.front();
        q.push(ele);
        q.pop();
        count++;
    }
    count=0;
    while(count<n){
        s.push(q.front());
        q.pop();
        count++;
    }
    while(!s.empty()){
        int stackele=s.top();
        s.pop();
        q.push(stackele);
        int qele= q.front();
        q.pop();
        q.push(qele);
    }
}

// Circular tour

class Solution{
public:
    //Function to find starting point where the truck can start to get through
    //the complete circle without exhausting its petrol in between.
    int tour(petrolPump p[],int n)
    {
       int deficit = 0;
       int balance = 0;
       int start = 0;
       for(int i=0; i<n; i++) {
           balance += p[i].petrol - p[i].distance;
           if(balance < 0) {
               start = i+1;
               deficit += balance;
               balance = 0;
           }
       }
       if(balance + deficit >=0) 
            return start;
        return -1;
    }
};

// Rotten Oranges

class Solution 
{
    private:
    class Pair {
    public:
        int row;
        int col;
        Pair(int r, int c) {
            this->row = r;
            this->col = c;
        }
    };
    int solve(vector<vector<int>> &matrix) {
        int n = matrix.size();
        int m = matrix[0].size();
        queue<Pair> q;
        int ans = 0;
        int ones = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix[i][j] == 2) {
                    q.push(Pair(i, j));
                } else if (matrix[i][j] == 1) {
                    ones++;
                }
            }
        }
        while (!q.empty()) {
            if (ones != 0) {
                ans += 1;
            }
            int size = q.size();
            for (int i = 0; i < size; i++) {
                Pair p = q.front();
                q.pop();    
                int r = p.row;
                int c = p.col;
                // Up
                if (r - 1 >= 0) {
                    if (matrix[r - 1][c] == 1) {
                        matrix[r - 1][c] = 2;
                        ones--;
                        q.push(Pair(r - 1, c));
                    }
                }
                // Down
                if (r + 1 < n) {
                    if (matrix[r + 1][c] == 1) {
                        matrix[r + 1][c] = 2;
                        ones--;
                        q.push(Pair(r + 1, c));
                    }
                }
                // Left
                if (c - 1 >= 0) {
                    if (matrix[r][c - 1] == 1) {
                        matrix[r][c - 1] = 2;
                        ones--;
                        q.push(Pair(r, c - 1));
                    }
                }
                // Right
                if (c + 1 < m) {
                    if (matrix[r][c + 1] == 1) {
                        matrix[r][c + 1] = 2;
                        ones--;
                        q.push(Pair(r, c + 1));
                    }
                }
            }
        }   
        return (ones==0)?ans:-1;
    }
    public:
    int orangesRotting(vector<vector<int>>& grid) {
        return solve(grid);
    }
};

// Distance of nearest cell having 1

class Solution 
{
    public:
    /*
    
     1.Take all 1's as the base level like a root of tree.
     2.Now make a answer matrix and initialize with -1.
     3.Find all 1 and push it to queue and update its distance to 0 in the answer matrix.
     4.Now traverse to all child of the 1's if the answer[i][j] of the child is -1 then update
     the answer by adding 1 to the distance of its parent.
     5.Finally return the answer matrix
     
     Similar question:
     Rotten oranges
     Knight Walk
     
    */
	vector<vector<int>>nearest(vector<vector<int>>grid)
	{
	    int row = grid.size();
	    int col = grid[0].size();
	    queue<pair<int,int>> q;
	    vector<vector<int>> ans(row,vector<int>(col,-1));
	    for(int i=0;i<row;i++)
	    {
	        for(int j=0;j<col;j++)
	        {
	            if(grid[i][j]==1) {
	                q.push({i,j});
	                ans[i][j]=0;
	            }
	        }
	    }
	    int dx[] = {0, 0, 1, -1};
	    int dy[] = {1, -1, 0 , 0};
	    int level=0;
	    while(!q.empty())
	    {
	        int size = q.size();
	        for(int i=0;i<size;i++) {
	            int a = q.front().first;
	            int b = q.front().second;
	            q.pop();
	            
	            for(int k=0;k<4;k++)
	            {
	                int na = a+dx[k];
	                int nb = b+dy[k];
	                if(na<0||nb<0||na>=row||nb>=col||ans[na][nb]!=-1) continue;
	                q.push({na,nb});
	                ans[na][nb]=ans[a][b]+1;
	            }
	        }
	    }
	    return ans;
	}
};

// First negative integer in every window of size k

vector<long long> printFirstNegativeInteger(long long int A[], long long int N, long long int K) {
         deque<long long int> dq;
         vector<long long> ans;
         int negative = -1;
         
         //process first window
         for(int i=0; i<K; i++) {
             if(A[i] < 0) {
                 dq.push_back(i);
             }
         }
         
         //push ans for FIRST window
         if(dq.size() > 0) {
             ans.push_back(A[dq.front()]);
         }
         else
         {
             ans.push_back(0);
         }
         
         //now process for remaining windows
         for(int i = K; i<N; i++) {
             //first pop out of window element
             
             
             if(!dq.empty() && (i - dq.front())>=K ) {
                 dq.pop_front();
             }
             
             //then push current element
             if(A[i] < 0)
                dq.push_back(i);
             
            // put in ans
            if(dq.size() > 0) {
                 ans.push_back(A[dq.front()]);
            }
            else
            {
                ans.push_back(0);
            }
         }
         return ans;
 }
 
 // Check if all levels of two trees are anagrams or not
 
 class Solution{
    public:
    // We traverse both trees simultaneously level by level.
    // We store each level both trees in vectors (or array).
    // To check if two vectors are anagram or not, we sort both and then compare.

    // function to check if both the levels of trees are same or not.
    bool compare(queue<Node*> &q1, queue<Node*> &q2){
        vector<int> first, second;
        int n1 = q1.size();
        for(int i = 0; i < n1; i++){
            Node* temp1 = q1.front();
            int ele1 = temp1->data;
            first.push_back(ele1);
            q1.pop();
            q1.push(temp1);
            Node* temp2 = q2.front();
            int ele2 = temp2->data;
            second.push_back(ele2);
            q2.pop();
            q2.push(temp2);
        }
        sort(first.begin(), first.end());
        sort(second.begin(), second.end());
        for(int i = 0; i < n1; i++){
            if(first[i] != second[i]) return false;
        }
        return true;
    }
    bool areAnagrams(Node *root1, Node *root2){
        queue<Node*> q1, q2;
        q1.push(root1);
        q2.push(root2);
        // level order traversal
        while(!q1.empty() && !q2.empty()){
            int n1 = q1.size();
            int n2 = q2.size();
            // size different.
            if(n1 != n2) return false;
            if(compare(q1, q2) == false) return false;
            // insert the next level into queues.
            for(int i = 0; i < n1; i++){
                Node* temp1 = q1.front();
                Node* temp2 = q2.front();
                q1.pop();
                q2.pop();
                if(temp1->left) q1.push(temp1->left);
                if(temp1->right) q1.push(temp1->right);   
                if(temp2->left) q2.push(temp2->left);
                if(temp2->right) q2.push(temp2->right);
            }   
        }
        if(q1.size() > 0 || q2.size() > 0) return false;
        return true;
    }
};

// Sum of minimum and maximum elements of all subarrays of size k.

#include<iostream>
#include<queue>
using namespace std;
int solve(int *arr, int n, int k) {
    deque<int> maxi(k);
    deque<int> mini(k);
    //Addition of first k size window
    for(int i=0; i<k; i++) {
        while(!maxi.empty() && arr[maxi.back()] <= arr[i])
            maxi.pop_back();
        while(!mini.empty() && arr[mini.back()] >= arr[i])
            mini.pop_back();
        maxi.push_back(i);
        mini.push_back(i);
    }
    int ans = 0;
    ans += arr[maxi.front()] + arr[mini.front()];
    //remaining windows ko process karlo
    for(int i=k; i<n; i++) {
        //next window
        //removal
        while(!maxi.empty() && i - maxi.front() >=k) {
            maxi.pop_front();
        }
        while(!mini.empty() && i - mini.front() >=k) {
            mini.pop_front();
        }
        //addition
        while(!maxi.empty() && arr[maxi.back()] <= arr[i])
            maxi.pop_back();
        while(!mini.empty() && arr[mini.back()] >= arr[i])
            mini.pop_back();
        maxi.push_back(i);
        mini.push_back(i);    
        ans += arr[maxi.front()] + arr[mini.front()];
    }
    return ans;
}

// Game with String

// Method-1
class Solution{
public:
    int minValue(string s, int k){
        int freq[26]={0};int ans=0;
        for(int i=0;i<s.size();i++)
            freq[s[i]-'a']++;
        for(int i=0;i<k;i++)
        {
            sort(freq,freq+26);
            freq[25]--;
        }
        for(int i=0;i<26;i++)
        ans+=freq[i]*freq[i];
        return ans;
    }
};

// Method-2
class Solution{
public:
    int minValue(string s, int k){
        priority_queue<int> pq;
        unordered_map<char,int> mp;
        int sum=0;
        
        for(int i=0;i<s.length();i++)
        {
            mp[s[i]]++;
        }
        for(auto i : mp){
            pq.push(i.second);
        }
        for(int i=0;i<k;i++)
        {
           int top=pq.top();
           pq.pop();
           pq.push(top-1);
        }
        while(!pq.empty())
        {
            int top=pq.top();
            sum=sum+(top*top);
            pq.pop();
        }
        return sum;
        
    }
};

// First non-repeating character in a stream

class Solution {
	public:
		string FirstNonRepeating(string A){
           unordered_map<char,int> mp;
           queue<char> q;
           string ans = "";
           
           for(int i = 0; i < A.length(); i++)
           {
               char ch = A[i];
               mp[ch]++;
               q.push(ch);
               
               while(!q.empty())
               {
                   if(mp[q.front()] > 1)
                        q.pop();
                    else{
                        ans.push_back(q.front());
                        break;
                    }
               }
               
               if(q.empty())
                    ans.push_back('#');
           }
           return ans;
        }
};

// Next smaller element

#include<stack>
vector<int> nextSmallerElement(vector<int> &arr, int n){
    stack<int> s;
    s.push(-1);
    vector<int> ans(n);
    for(int i=n-1;i>=0;i--){
        int curr = arr[i];
        while (s.top() >= curr) {
            s.pop();
        }
        ans[i] = s.top();
        s.push(curr);
    }
    return ans;
}

// Previous Smaller element

#include<stack>
vector<int> nextSmallerElement(vector<int> &arr, int n){
    stack<int> s;
    s.push(-1);
    vector<int> ans(n);
    for(int i=0;i<n;i++){
        int curr = arr[i];
        while (s.top() >= curr) {
            s.pop();
        }
        ans[i] = s.top();
        s.push(curr);
    }
    return ans;
}
