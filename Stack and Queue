// Implementation of stack using array

#include<iostream>
#include<stack>
using namespace std;

class Stack{
    // properties
    public:
        int top;
        int *arr;
        int size;
    // behaviour
    Stack(int size){
        this->size=size;
        arr=new int[size];
        top=-1;
    }
    void push(int element){
        if(size-top>1){
            top++;
            arr[top]=element;
        }
        else{
            cout<<"Stack Overflow "<<endl;
        }
    }
    int peek(){
        if(top>=0){
            return arr[top];
        }
        else{
            cout<<"Stack is empty "<<endl;
            return -1;
        }
    }
    void pop(){
        if(top>=0){
            top--;
        }
        else{
            cout<<"Stack UnderFlow "<<endl;
        }
    }
    bool isEmpty(){
        if(top==-1){
            return true;
        }
        else{
            return false;
        }
    }
};
int main(){
    /* 
    stack<int> s;
    s.push(2);
    s.push(1);
    s.push(3);
    s.pop();
    cout<<"printing top element "<<s.top()<<endl;
    if(s.empty()){
        cout<<"Stack is empty "<<endl;
    }
    else{
        cout<<"Stack is not empty "<<endl;
    }
    cout<<"Size of the stack is: "<<s.size()<<endl; 
    */
    Stack st(5);
    st.push(10);
    st.push(3);
    st.push(7);
    cout<<"Peek element is: "<<st.peak()<<endl;
    st.pop();
    cout<<"Peek element is: "<<st.peak()<<endl;
    cout<<"Empty or not: "<<st.isEmpty()<<endl;
    return 0;
}

// Implementation of stack using Linked list

#include <bits/stdc++.h>
using namespace std;
// creating a linked list;
class Node {
public:
	int data;
	Node *link;
	// Constructor
	Node(int n){
		this->data = n;
		this->link = NULL;
	}
};
class Stack {
	Node *top;
    public:
	Stack() { 
        top = NULL; 
    }
	void push(int data){
		// Create new node temp and allocate memory in heap
		Node* temp = new Node(data);
		// Check if stack (heap) is full. Then inserting an element would lead to stack overflow
		if (!temp) {
			cout << "\nStack Overflow";
			exit(1);
		}
		// Initialize data into temp data field
		temp->data = data;
		// Put top pointer reference into temp link
		temp->link = top;
		// Make temp as top of Stack
		top = temp;
	}
	// Utility function to check if the stack is empty or not
	bool isEmpty(){
		// If top is NULL it means that there are no elements are in stack
		return top == NULL;
	}
	// Utility function to return top element in a stack
	int peek(){
		// If stack is not empty , return the top element
		if (!isEmpty())
			return top->data;
		else
			exit(1);
	}
	// Function to remove a key from given queue q
	void pop(){
		Node* temp;
		// Check for stack underflow
		if (top == NULL) {
			cout << "\nStack Underflow" << endl;
			exit(1);
		}
		else {
			// Assign top to temp
			temp = top;
			// Assign second node to top
			top = top->link;
			// This will automatically destroy the link between first node and second node
			// Release memory of top node i.e delete the node
			free(temp);
		}
	}
	// Function to print all the elements of the stack
	void display(){
		Node* temp;
		// Check for stack underflow
		if (top == NULL) {
			cout << "\nStack Underflow";
			exit(1);
		}
		else {
			temp = top;
			while (temp != NULL) {
				// Print node data
				cout << temp->data;
				// Assign temp link to temp
				temp = temp->link;
				if (temp != NULL)
					cout << " -> ";
			}
		}
	}
};
int main(){
	// Creating a stack
	Stack s;
	// Push the elements of stack
	s.push(11);
	s.push(22);
	s.push(33);
	s.push(44);
	// Display stack elements
	s.display();
	// Print top element of stack
	cout << "\nTop element is " << s.peek() << endl;
	// Delete top elements of stack
	s.pop();
	s.pop();
	// Display stack elements
	s.display();
	// Print top element of stack
	cout << "\nTop element is " << s.peek() << endl;
	return 0;
}
